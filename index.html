<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Rubik's Cube with Rotations</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    canvas {
      display: block;
    }

    .instructions {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
    }

    h1 {
      margin: 0 0 10px 0;
      font-size: 18px;
    }

    ul {
      margin: 0;
      padding-left: 20px;
    }

    li {
      margin-bottom: 5px;
    }
  </style>
</head>

<body>
  <div class="instructions">
    <h1>Rubik's Cube 3D - Instrucciones</h1>
    <ul>
      <li>Rotar el cubo: Arrastrar con el mouse</li>
      <li>Rotar caras:
        <ul>
          <li>Derecha: Flecha derecha (→)</li>
          <li>Izquierda: Flecha izquierda (←)</li>
          <li>Arriba: Flecha arriba (↑)</li>
          <li>Abajo: Flecha abajo (↓)</li>
          <li>Frente: Tecla 'f'</li>
          <li>Atrás: Tecla 'b'</li>
        </ul>
      </li>
    </ul>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // Crear una escena
    const scene = new THREE.Scene();

    // Crear una cámara
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    // Crear un renderizador
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Crear el cubo de Rubik
    const cubeSize = 1;
    const spacing = 0.01;
    const rubiksCube = new THREE.Group();

    const colors = [
      0xff0000, // rojo
      0x00ff00, // verde
      0x0000ff, // azul
      0xffff00, // amarillo
      0xffa500, // naranja
      0xffffff  // blanco
    ];

    for (let x = -1; x <= 1; x++) {
      for (let y = -1; y <= 1; y++) {
        for (let z = -1; z <= 1; z++) {
          const geometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
          const materials = colors.map(color => new THREE.MeshBasicMaterial({ color }));
          const cube = new THREE.Mesh(geometry, materials);
          cube.position.set(
            x * (cubeSize + spacing),
            y * (cubeSize + spacing),
            z * (cubeSize + spacing)
          );
          rubiksCube.add(cube);
        }
      }
    }

    scene.add(rubiksCube);

    // Variables para controlar la rotación del cubo completo
    let isDragging = false;
    let previousMousePosition = {
      x: 0,
      y: 0
    };

    // Función para rotar una capa
    function rotateFace(axis, layer, direction) {
      const rotationAngle = Math.PI / 2 * direction;
      rubiksCube.children.forEach(cube => {
        if (Math.round(cube.position[axis]) === layer) {
          cube.position.applyAxisAngle(new THREE.Vector3(...axis === 'x' ? [1, 0, 0] : axis === 'y' ? [0, 1, 0] : [0, 0, 1]), rotationAngle);
          cube.rotateOnWorldAxis(new THREE.Vector3(...axis === 'x' ? [1, 0, 0] : axis === 'y' ? [0, 1, 0] : [0, 0, 1]), rotationAngle);
        }
      });
    }

    // Manejo de eventos de teclado
    document.addEventListener('keydown', (event) => {
      switch (event.key) {
        case 'ArrowRight': rotateFace('x', 1, 1); break;
        case 'ArrowLeft': rotateFace('x', -1, -1); break;
        case 'ArrowUp': rotateFace('y', 1, 1); break;
        case 'ArrowDown': rotateFace('y', -1, -1); break;
        case 'f': rotateFace('z', 1, 1); break;
        case 'b': rotateFace('z', -1, -1); break;
      }
    });

    // Eventos del mouse para rotar el cubo completo
    renderer.domElement.addEventListener('mousedown', (e) => {
      isDragging = true;
    });

    renderer.domElement.addEventListener('mousemove', (e) => {
      if (isDragging) {
        const deltaMove = {
          x: e.offsetX - previousMousePosition.x,
          y: e.offsetY - previousMousePosition.y
        };

        rubiksCube.rotation.y += deltaMove.x * 0.01;
        rubiksCube.rotation.x += deltaMove.y * 0.01;
      }

      previousMousePosition = {
        x: e.offsetX,
        y: e.offsetY
      };
    });

    renderer.domElement.addEventListener('mouseup', (e) => {
      isDragging = false;
    });

    // Función de animación
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>

</html>